import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
} from 'docx';
import { saveAs } from 'file-saver';
import type { DeliverableId } from '../contracts';
import {
  CLIENT_EXPORT_DELIVERABLES,
  getDeliverableFilename,
  getDeliverableTitle,
} from '../contracts';
import { sanitizeForClient } from './sanitizer';

declare global {
  interface Window {
    JSZip: typeof import('jszip');
  }
}

async function loadJSZip(): Promise<typeof import('jszip')> {
  if (typeof window !== 'undefined' && window.JSZip) {
    return window.JSZip;
  }

  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
  document.head.appendChild(script);

  return new Promise((resolve, reject) => {
    script.onload = () => {
      if (window.JSZip) {
        resolve(window.JSZip);
      } else {
        reject(new Error('Failed to load JSZip'));
      }
    };
    script.onerror = () => reject(new Error('Failed to load JSZip script'));
  });
}

async function generateDocxBlob(
  deliverableId: DeliverableId,
  content: unknown,
  projectTitle: string
): Promise<Blob | null> {
  const doc = await createDocument(deliverableId, content, projectTitle);
  if (!doc) return null;
  return Packer.toBlob(doc);
}

function createDocument(
  deliverableId: DeliverableId,
  content: unknown,
  projectTitle: string
): Document | null {
  const sanitized = sanitizeForClient(deliverableId, content);
  if (!sanitized) return null;

  const jsonContent = JSON.stringify(sanitized, null, 2);

  return new Document({
    sections: [
      {
        children: [
          new Paragraph({
            children: [
              new TextRun({
                text: `${projectTitle} - ${deliverableId}`,
                bold: true,
                size: 48,
              }),
            ],
            spacing: { after: 400 },
          }),
          new Paragraph({
            text: 'JSON Export',
            heading: HeadingLevel.HEADING_2,
            spacing: { after: 200 },
          }),
          new Paragraph({
            children: [
              new TextRun({
                text: jsonContent,
                font: 'Courier New',
                size: 18,
              }),
            ],
          }),
        ],
      },
    ],
  });
}

export async function generateExportZip(
  projectTitle: string,
  artifacts: Map<DeliverableId, { content: unknown; validated: boolean }>
): Promise<void> {
  const JSZip = await loadJSZip();
  const zip = new JSZip();

  const safeName = projectTitle.replace(/[^a-zA-Z0-9]/g, '_');

  const jsonFolder = zip.folder('json');
  const docxFolder = zip.folder('docx');

  for (const id of CLIENT_EXPORT_DELIVERABLES) {
    const artifact = artifacts.get(id);
    if (!artifact || !artifact.validated) continue;

    const sanitized = sanitizeForClient(id, artifact.content);
    const filename = getDeliverableFilename(id);

    if (sanitized) {
      jsonFolder?.file(`${filename}.json`, JSON.stringify(sanitized, null, 2));
    }

    try {
      const docBlob = await generateDocxBlob(id, artifact.content, projectTitle);
      if (docBlob) {
        const arrayBuffer = await docBlob.arrayBuffer();
        docxFolder?.file(`${filename}.docx`, arrayBuffer);
      }
    } catch (error) {
      console.warn(`Failed to generate DOCX for ${id}:`, error);
    }
  }

  const readmeContent = `# ${projectTitle} - WebinarRev Export

Generated: ${new Date().toISOString()}

## Contents

### JSON Files
Raw content data in JSON format for each deliverable.

### DOCX Files
Formatted documents ready for review and editing.

## Deliverables Included

${CLIENT_EXPORT_DELIVERABLES
  .filter((id) => artifacts.get(id)?.validated)
  .map((id) => `- ${getDeliverableTitle(id)}`)
  .join('\n')}

---
Generated by WebinarRev V1
`;

  zip.file('README.md', readmeContent);

  const blob = await zip.generateAsync({ type: 'blob' });
  saveAs(blob, `${safeName}_WebinarRev_Package.zip`);
}
