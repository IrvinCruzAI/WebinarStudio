import { Document, Paragraph, TextRun, HeadingLevel, Packer, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';

interface ExportSection {
  title: string;
  content: string | string[] | object;
}

const flattenContent = (content: string | string[] | object): string[] => {
  if (typeof content === 'string') {
    return content.split('\n').filter(line => line.trim());
  }
  if (Array.isArray(content)) {
    return content.map(item =>
      typeof item === 'object' ? JSON.stringify(item, null, 2) : String(item)
    );
  }
  if (typeof content === 'object') {
    return Object.entries(content).map(([key, value]) => {
      if (typeof value === 'object') {
        return `${key}: ${JSON.stringify(value, null, 2)}`;
      }
      return `${key}: ${value}`;
    });
  }
  return [String(content)];
};

export const exportToDocx = async (
  title: string,
  sections: ExportSection[],
  filename: string
) => {
  const children: Paragraph[] = [
    new Paragraph({
      text: title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 }
    }),
    new Paragraph({
      text: `Generated by Webinar Rev on ${new Date().toLocaleDateString()}`,
      alignment: AlignmentType.CENTER,
      spacing: { after: 600 },
      children: [
        new TextRun({
          text: `Generated by Webinar Rev on ${new Date().toLocaleDateString()}`,
          italics: true,
          color: '666666'
        })
      ]
    })
  ];

  sections.forEach(section => {
    children.push(
      new Paragraph({
        text: section.title,
        heading: HeadingLevel.HEADING_1,
        spacing: { before: 400, after: 200 }
      })
    );

    const lines = flattenContent(section.content);
    lines.forEach(line => {
      children.push(
        new Paragraph({
          text: line,
          spacing: { after: 120 }
        })
      );
    });
  });

  const doc = new Document({
    sections: [{ children }]
  });

  const blob = await Packer.toBlob(doc);
  saveAs(blob, `${filename}.docx`);
};

export const exportContentSummary = async (data: any, webinarTitle: string) => {
  const sections: ExportSection[] = [
    {
      title: 'One-Line Value',
      content: [data.oneLineValue || '']
    },
    {
      title: 'Key Takeaways',
      content: data.keyTakeaways || []
    },
    {
      title: 'Content Outline',
      content: (data.contentOutline || []).map(
        (item: any) => `${item.section} (${item.duration})\nKey Points: ${(item.keyPoints || []).join(', ')}`
      )
    },
    {
      title: 'Audience Profile',
      content: [data.audienceProfile || '']
    },
    {
      title: 'Recommended Marketing Angles',
      content: data.recommendedAngles || []
    }
  ];

  await exportToDocx(
    `Content Summary: ${webinarTitle}`,
    sections,
    `content-summary-${webinarTitle.toLowerCase().replace(/\s+/g, '-')}`
  );
};

export const exportCopyPack = async (data: any, webinarTitle: string) => {
  const sections: ExportSection[] = [];

  if (data.messagingFoundation) {
    sections.push({
      title: 'Messaging Foundation',
      content: [
        `One-Line Promise: ${data.messagingFoundation.oneLinePromise}`,
        `Core Problem: ${data.messagingFoundation.coreProblem}`,
        `Unique Mechanism: ${data.messagingFoundation.uniqueMechanism}`,
        '',
        'Key Takeaways:',
        ...(data.messagingFoundation.keyTakeaways || []).map((t: string) => `- ${t}`),
        '',
        'Proof Points:',
        ...(data.messagingFoundation.proofPoints || []).map((p: string) => `- ${p}`),
        '',
        'Objections & Rebuttals:',
        ...(data.messagingFoundation.topObjectionsAndRebuttals || []).map((o: any) =>
          `Q: ${o.objection}\nA: ${o.rebuttal}`
        )
      ]
    });
  }

  if (data.landingPage) {
    const lp = data.landingPage;
    sections.push({
      title: 'Landing Page',
      content: [
        '=== HERO ===',
        `Headline: ${lp.hero?.headline || ''}`,
        `Subheadline: ${lp.hero?.subheadline || ''}`,
        `CTA: ${lp.hero?.ctaText || ''}`,
        '',
        '=== SECTIONS ===',
        ...(lp.sections || []).flatMap((s: any) => [
          `\n## ${s.title}`,
          s.contentMarkdown
        ]),
        '',
        '=== FAQ ===',
        ...(lp.faq || []).map((f: any) => `Q: ${f.q}\nA: ${f.a}`),
        '',
        '=== FINAL CTA ===',
        `Headline: ${lp.finalCtaBlock?.headline || ''}`,
        'Bullets:',
        ...(lp.finalCtaBlock?.bullets || []).map((b: string) => `- ${b}`),
        `CTA: ${lp.finalCtaBlock?.ctaText || ''}`
      ]
    });
  }

  if (data.emailSequence) {
    sections.push({
      title: 'Email Sequence',
      content: [
        `Sender Name Suggestion: ${data.emailSequence.senderNameSuggestion || ''}`,
        '',
        ...(data.emailSequence.emails || []).flatMap((email: any) => [
          `\n=== ${email.type.toUpperCase()} ===`,
          `Subject: ${email.subject}`,
          `Preheader: ${email.preheader}`,
          `Send Timing: ${email.sendTiming}`,
          '',
          email.bodyMarkdown,
          ''
        ])
      ]
    });
  }

  if (data.socialPosts) {
    const social = data.socialPosts;
    sections.push({
      title: 'Social Media Posts',
      content: [
        '=== LINKEDIN LONG-FORM ===',
        ...(social.linkedin || []).flatMap((p: any) => [
          `\nHook: ${p.hook}`,
          p.body,
          `CTA: ${p.ctaLine}`,
          ''
        ]),
        '',
        '=== SHORT POSTS ===',
        ...(social.shortPosts || []).map((p: any) =>
          `\n[${p.platform.toUpperCase()}]\n${p.text}`
        )
      ]
    });
  }

  await exportToDocx(
    `Copy Pack: ${webinarTitle}`,
    sections,
    `copy-pack-${webinarTitle.toLowerCase().replace(/\s+/g, '-')}`
  );
};

export const exportRunOfShow = async (data: any, webinarTitle: string) => {
  const sections: ExportSection[] = [
    {
      title: 'Overview',
      content: [`Total Duration: ${data.totalDuration || 60} minutes`]
    },
    {
      title: 'Segments',
      content: (data.segments || []).map((seg: any) =>
        `[${seg.startTime}] ${seg.segment} (${seg.duration} min)\n` +
        `Description: ${seg.description}\n` +
        `Speaker Notes: ${seg.speakerNotes}\n` +
        (seg.ctaMoment ? '*** CTA MOMENT ***\n' : '') +
        (seg.transition ? `Transition: ${seg.transition}` : '')
      )
    }
  ];

  await exportToDocx(
    `Run-of-Show: ${webinarTitle}`,
    sections,
    `run-of-show-${webinarTitle.toLowerCase().replace(/\s+/g, '-')}`
  );
};

export const exportChecklist = async (data: any, webinarTitle: string) => {
  const sections: ExportSection[] = [
    {
      title: 'Pre-Webinar Tasks',
      content: (data.preWebinar || []).map(
        (item: any) => `[ ] ${item.task} (${item.timing})`
      )
    },
    {
      title: 'During Webinar Tasks',
      content: (data.duringWebinar || []).map(
        (item: any) => `[ ] ${item.task} (${item.timing})`
      )
    },
    {
      title: 'Post-Webinar Tasks',
      content: (data.postWebinar || []).map(
        (item: any) => `[ ] ${item.task} (${item.timing})`
      )
    }
  ];

  await exportToDocx(
    `Webinar Checklist: ${webinarTitle}`,
    sections,
    `checklist-${webinarTitle.toLowerCase().replace(/\s+/g, '-')}`
  );
};

export const copyToClipboard = async (text: string): Promise<boolean> => {
  try {
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
};

export const formatDataForCopy = (data: any, type: string): string => {
  switch (type) {
    case 'WR2':
      return [
        `# ${data.oneLineValue || 'Content Summary'}`,
        '',
        '## Key Takeaways',
        ...(data.keyTakeaways || []).map((t: string) => `- ${t}`),
        '',
        '## Content Outline',
        ...(data.contentOutline || []).flatMap((s: any) => [
          `### ${s.section} (${s.duration})`,
          ...s.keyPoints.map((kp: string) => `- ${kp}`),
          ''
        ]),
        '## Audience Profile',
        data.audienceProfile || '',
        '',
        '## Recommended Angles',
        ...(data.recommendedAngles || []).map((a: string) => `- ${a}`)
      ].join('\n');

    case 'WR3':
      return [
        `# Run-of-Show (${data.totalDuration || 60} minutes)`,
        '',
        ...(data.segments || []).map((seg: any) =>
          `## [${seg.startTime}] ${seg.segment} (${seg.duration} min)\n` +
          `${seg.description}\n\n` +
          `**Speaker Notes:** ${seg.speakerNotes}\n` +
          (seg.ctaMoment ? `\n**CTA MOMENT**\n` : '') +
          (seg.transition ? `\n*Transition:* ${seg.transition}` : '')
        )
      ].join('\n');

    case 'WR4':
      if (data.rendering?.copyPackMarkdown) {
        return data.rendering.copyPackMarkdown;
      }

      const lp = data.landingPage || {};
      const emails = data.emailSequence?.emails || [];
      const social = data.socialPosts || {};

      return [
        '# Copy Pack',
        '',
        '## Messaging Foundation',
        `**One-Line Promise:** ${data.messagingFoundation?.oneLinePromise || ''}`,
        `**Core Problem:** ${data.messagingFoundation?.coreProblem || ''}`,
        `**Unique Mechanism:** ${data.messagingFoundation?.uniqueMechanism || ''}`,
        '',
        '## Landing Page',
        `### ${lp.hero?.headline || ''}`,
        lp.hero?.subheadline || '',
        '',
        ...(lp.sections || []).flatMap((s: any) => [
          `#### ${s.title}`,
          s.contentMarkdown,
          ''
        ]),
        '',
        '## Email Sequence',
        ...emails.map((e: any) =>
          `### ${e.type}: ${e.subject}\n*${e.preheader}*\n*Send: ${e.sendTiming}*\n\n${e.bodyMarkdown}`
        ),
        '',
        '## Social Posts',
        '### LinkedIn',
        ...(social.linkedin || []).flatMap((p: any) => [
          `**Hook:** ${p.hook}`,
          p.body,
          `**CTA:** ${p.ctaLine}`,
          ''
        ]),
        '',
        '### Short Posts',
        ...(social.shortPosts || []).map((p: any) =>
          `**[${p.platform.toUpperCase()}]**\n${p.text}`
        )
      ].join('\n');

    case 'WR5':
      return [
        '# Webinar Checklist',
        '',
        '## Pre-Webinar',
        ...(data.preWebinar || []).map((t: any) => `- [ ] ${t.task} *(${t.timing})*`),
        '',
        '## During Webinar',
        ...(data.duringWebinar || []).map((t: any) => `- [ ] ${t.task} *(${t.timing})*`),
        '',
        '## Post-Webinar',
        ...(data.postWebinar || []).map((t: any) => `- [ ] ${t.task} *(${t.timing})*`)
      ].join('\n');

    default:
      return JSON.stringify(data, null, 2);
  }
};
